import {offset,arrow,computePosition}from'../vendor/floating.js';import dayjs from'../vendor/dayjs.js';class JaXCore {
    /**
     * Create a new JaXCore instance.
     */
    constructor() {
        this.container = new Map;
        this.directives = new Map;
        this.components = new Map;
    }
    /**
     * Basic querySelector helper
     * @param selector
     * @param context
     * @returns
     */
    select(selector, context = null) {
        return (context || document).querySelector(selector);
    }
    /**
     * Basic querySelectorAll Helper
     * @param selector
     * @param context
     * @returns
     */
    query(selector, context = null) {
        return (context || document).querySelectorAll(selector);
    }
    /**
     * Get something from the container.
     * @param key
     * @param defValue
     * @returns
     */
    get(key, defValue = null) {
        return this.container.has(key) ? this.container.get(key) : defValue;
    }
    /**
     * Set something into the container.
     * @param key
     * @param value
     * @returns
     */
    set(key, value) {
        if (this.container.has(key)) {
            throw new Error(`The container key '${key}' has already been registered.`);
        }
        this.container.set(key, value);
    }
    /**
     * Register a new HTML directive.
     * @param name
     * @param handler
     * @param targetTypes
     * @returns
     */
    directive(name, directive) {
        if (this.directives.has(name)) {
            throw new Error(`The directive '${name}' has already been registered.`);
        }
        this.directives.set(name, directive);
    }
    /**
     * Register a new Component.
     * @param alias
     * @param cls
     * @returns
     */
    component(alias, cls) {
        alias = alias.charAt(0).toUpperCase() + alias.slice(1);
        if (this.components.has(alias)) {
            throw new Error(`The component '${alias}' has already been registered.`);
        }
        this[alias] = cls;
        this.components.set(alias, cls);
    }
    /**
     * Initialize a new plugin
     * @param handler
     * @returns
     */
    plugin(handler) {
        handler.call(globalThis, this);
    }
    /**
     * Register a utility function
     * @param key
     * @param callback
     */
    utility(key, callback) {
        if (key.toLowerCase() in this) {
            throw new Error(`The utility key '${key}' cannot be registered.`);
        }
        this[key.toLowerCase()] = callback;
    }
    /**
     * Wait for
     * @param selector
     * @param handler
     */
    waitFor(selector, handler) {
        const observer = new MutationObserver(() => {
            let elements = document.querySelectorAll(`${selector}:not([data-jdone])`);
            if (elements.length > 0) {
                [].map.call(elements, el => {
                    el.dataset.jdone = true;
                    handler(el);
                });
            }
            if (document.readyState === 'complete') {
                observer.disconnect();
            }
        });
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
        const interval = setInterval(() => {
            if (document.readyState === 'complete') {
                observer.disconnect();
                clearInterval(interval);
            }
        }, 1000);
    }
    /**
     * Start JaX environment
     */
    start() {
        const onReady = new Map;
        for (const [name, directive] of this.directives.entries()) {
            if (directive.isLazy()) {
                onReady.set(name, directive.getHandler());
            }
            else {
                if (document.readyState !== 'loading') {
                    [].map.call(this.query(`[data-${name}]`), el => directive.getHandler()(el));
                }
                else {
                    this.waitFor(`[data-${name}]`, directive.getHandler());
                }
            }
        }
        const handler = () => {
            for (const [name, handler] of onReady) {
                [].map.call(this.query(`[data-${name}]`), el => handler(el));
            }
        };
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', handler.bind(this));
        }
        else {
            handler();
        }
    }
}class Icons {
    /**
     * Create new Icons Repository
     */
    constructor() {
        this.icons = new Map;
    }
    /**
     * Get or Load an Icon
     * @param icon
     * @param size
     * @returns
     */
    async load(icon, size = 16) {
        if (!icon.endsWith('.svg')) {
            icon += '.svg';
        }
        if (this.icons.has(icon)) {
            return this.render(icon, size);
        }
        // Request Icon
        let base = window.location.origin;
        let request = await fetch(`${base}/@crate/backend/icons/${icon}`, {
            method: 'GET'
        });
        let response = await request.text();
        // Validate
        response = response.trim();
        if (!response.startsWith('<svg')) {
            throw new Error(`The passed icon name '${icon}' is invalid or an request error occured.`);
        }
        // Cache
        const element = ((icon) => {
            let temp = document.createElement('DIV');
            temp.innerHTML = icon;
            return temp.children[0];
        })(response);
        this.icons.set(icon, element);
        // Return
        return this.render(icon, size);
    }
    /**
     * Render a Cached Item
     * @param icon
     * @param size
     * @returns
     */
    render(icon, size = 16) {
        if (!this.icons.has(icon)) {
            throw new Error(`The passed icon name '${icon}' is not available.`);
        }
        let result = this.icons.get(icon).cloneNode(true);
        if (size !== 16) {
            result.setAttribute('width', `${size}px`);
            result.setAttribute('height', `${size}px`);
        }
        return result;
    }
}
/**
 * Register JaX Plugin
 * @param JaX
 */
function IconsPlugin(JaX) {
    JaX.set('icons', new Icons);
}class Directive {
    /**
     * Create a new Directive
     * @param name
     * @param handler
     * @param lazy
     */
    constructor(name, handler, options = {}) {
        this.name = name;
        this.handler = handler;
        this.lazy = 'lazy' in options ? options.lazy : true;
    }
    /**
     * Get Directive Name
     * @returns
     */
    getName() {
        return this.name;
    }
    /**
     * Get Directive Handler
     * @returns
     */
    getHandler() {
        return this.handler;
    }
    /**
     * Check if Directive is set to Lazy.
     * @returns
     */
    isLazy() {
        return this.lazy;
    }
}/**
 * Merge default options with passed one or element dataset ones.
 * @param defOptions
 * @param options
 * @param element
 * @param prefix
 * @returns
 */
function mergeOptions(defOptions, options, element, prefix) {
    const result = {};
    for (const [key, val] of Object.entries(defOptions)) {
        const datasetKey = prefix + key.charAt(0).toUpperCase() + key.slice(1);
        if (key in options) {
            result[key] = options[key];
        }
        else if (datasetKey in element.dataset) {
            let value = element.dataset[datasetKey];
            let temp = element.dataset[datasetKey];
            if (typeof val === 'boolean') {
                value = temp === '' || temp.toLowerCase() === 'true' || temp.toLowerCase() === 'on' || temp.toLowerCase() === 'yes';
            }
            else if (typeof val === 'number') {
                value = val === +val && val !== (val | 0) ? parseFloat(temp) : parseInt(temp);
            }
            result[key] = value;
        }
        else {
            result[key] = val;
        }
    }
    return result;
}
/**
 * Ready Promise
 * @returns
 */
function ready() {
    return new Promise((resolve, reject) => {
        const isReady = () => {
            if (document.readyState !== 'loading') {
                resolve(true);
                return;
            }
            setTimeout(isReady, 100);
        };
        isReady();
    });
}class Offcanvas {
    /**
     * Crate a new Offcanvas.
     */
    constructor(target, options = {}) {
        this.target = target;
        this.target.addEventListener('click', this.toggle.bind(this));
        document.addEventListener('click', this.outside.bind(this));
        this.options = mergeOptions({
            animation: 'slide',
            backdrop: true,
            keyboard: true,
            scrollable: true
        }, options, target, 'offcanvas');
    }
    /**
     * Hide when click outside
     * @param event
     * @returns
     */
    outside(event) {
        if (!('offcanvasVisible' in this.target.dataset)) {
            return;
        }
        const target = event.target;
        if (!target.closest(`#${this.target.dataset.offcanvasVisible}`)) {
            if (!target.closest(`[data-offcanvas-visible="${this.target.dataset.offcanvasVisible}"]`)) {
                this.hide(event);
            }
        }
    }
    /**
     * Toggle Offcanvas Screen
     * @param event
     */
    toggle(event) {
        if ('offcanvasVisible' in this.target.dataset) {
            this.hide(event);
        }
        else {
            this.show(event);
        }
    }
    /**
     * Show Offcanvas
     * @param event
     * @returns
     */
    show(event) {
        const templates = window['JaX'].get('templates');
        const template = this.target.dataset.offcanvas;
        if (!templates.has(template)) {
            throw new Error(`The offcanvas template '${template}' does not exist.`);
        }
        // Render Offcanvas Template
        let offcanvas = templates.render(template);
        if (!offcanvas.classList.contains('offcanvas')) {
            throw new Error(`The offcanvas template '${template}' is invalid.`);
        }
        offcanvas.id = `offcanvas__${template}`;
        // Set Visibility
        this.target.dataset.offcanvasVisible = offcanvas.id;
        // Append Offcanvas
        if (this.options.backdrop) {
            this.backdrop = document.createElement('DIV');
            this.backdrop.className = 'backdrop';
            document.body.appendChild(this.backdrop);
        }
        document.body.appendChild(offcanvas);
        setTimeout(() => { offcanvas.classList.add('show'); }, 10);
    }
    /**
     * Hide Offcanvas
     * @param event
     * @returns
     */
    hide(event) {
        let offcanvas = document.querySelector(`#${this.target.dataset.offcanvasVisible}`);
        offcanvas.classList.remove('show');
        setTimeout(() => {
            offcanvas.remove();
            if (this.backdrop) {
                this.backdrop.remove();
                this.backdrop = null;
            }
            delete this.target.dataset.offcanvasVisible;
        }, 310);
    }
}
/**
 * Register JaX Plugin
 * @param JaX
 */
function OffcanvasPlugin(JaX) {
    JaX.component('Offcanvas', Offcanvas);
    JaX.directive('offcanvas', new Directive('offcanvas', (target) => {
        new Offcanvas(target);
    }));
}class Popover {
    /**
     * Crate a new Popover.
     */
    constructor(target) {
        this.target = target;
        this.target.addEventListener('click', this.toggle.bind(this));
        document.addEventListener('click', this.outside.bind(this));
    }
    /**
     * Hide when click outside
     * @param event
     * @returns
     */
    outside(event) {
        if (!('popoverVisible' in this.target.dataset)) {
            return;
        }
        const target = event.target;
        if (!target.closest(`#${this.target.dataset.popoverVisible}`)) {
            if (!target.closest(`[data-popover-visible="${this.target.dataset.popoverVisible}"]`)) {
                this.hide(event);
            }
        }
    }
    /**
     * Toggle Popover
     * @param event
     * @returns
     */
    toggle(event) {
        if ('popoverVisible' in this.target.dataset) {
            this.hide(event);
        }
        else {
            this.show(event);
        }
    }
    /**
     * Show Popover
     * @param event
     * @returns
     */
    show(event) {
        const templates = window['JaX'].get('templates');
        const template = this.target.dataset.popover;
        if (!templates.has(template)) {
            throw new Error(`The popover template '${template}' does not exist.`);
        }
        // Render Popover Template
        let popover = templates.render(template);
        if (!popover.classList.contains('popover')) {
            popover = ((child) => {
                let temp = document.createElement('DIV');
                temp.className = 'popover';
                temp.appendChild(child);
                return temp;
            })(popover);
        }
        popover.id = `popover__${template}`;
        // Set Visibility
        this.target.dataset.popoverVisible = popover.id;
        // Add Popover Arrow
        let popoverArrow = popover.querySelector('.popover-arrow');
        if (!popoverArrow) {
            popoverArrow = document.createElement('DIV');
            popoverArrow.className = 'popover-arrow';
            popover.appendChild(popoverArrow);
        }
        // Popover Placement
        const options = {
            middleware: [
                offset(10),
                arrow({
                    element: popoverArrow
                })
            ]
        };
        if ('popoverPlacement' in this.target.dataset) {
            options.placement = this.target.dataset.popoverPlacement;
        }
        // Append & Positionate
        document.body.appendChild(popover);
        computePosition(this.target, popover, options).then(({ x, y, placement, middlewareData }) => {
            popover.style.top = `${y}px`;
            popover.style.left = `${x}px`;
            const { x: arrowX, y: arrowY } = middlewareData.arrow;
            if (arrowY !== null) {
                popoverArrow.style.top = `${arrowY}px`;
            }
            if (arrowY !== null) {
                popoverArrow.style.left = `${arrowX}px`;
            }
        });
    }
    /**
     * Hide Popover
     * @param event
     * @returns
     */
    hide(event) {
        let popover = document.querySelector(`#${this.target.dataset.popoverVisible}`);
        if (popover) {
            popover.remove();
        }
        delete this.target.dataset.popoverVisible;
    }
}
/**
 * Register JaX Plugin
 * @param JaX
 */
function PopoverPlugin(JaX) {
    JaX.component('Popover', Popover);
    JaX.directive('popover', new Directive('popover', (target) => {
        new Popover(target);
    }));
}class Templates {
    /**
     * Create a new Persistent Storage.
     */
    constructor(JaX) {
        if (Templates.instance) {
            throw new Error('The Persistent Storage class cannot be initialized twice.');
        }
        Templates.instance = this;
        this.JaX = JaX;
        this.templates = new Map;
    }
    /**
     *
     * @returns
     */
    static getInstance() {
        if (!this.instance) {
            new this;
        }
        return this.instance;
    }
    /**
     * Check if a Template exists
     * @param key
     * @returns
     */
    has(key) {
        return this.templates.has(key);
    }
    /**
     * Get an existing Template
     * @param key
     * @returns
     */
    get(key) {
        return this.templates.get(key) || null;
    }
    /**
     * Set a new Template
     * @param key
     * @param template
     */
    set(key, template) {
        this.templates.set(key, template);
    }
    /**
     * Return prepared Template
     * @param key
     */
    render(key) {
        if (!this.templates.has(key)) {
            throw new Error(`The passed template name '${key}' does not exist.`);
        }
        const template = this.templates.get(key).cloneNode(true);
        let content = [].filter.call(template.content.childNodes, el => el instanceof HTMLElement);
        if (content.length > 1) {
            content = ((inner) => {
                let result = document.createElement('DIV');
                inner.map(el => result.appendChild(el));
                return result;
            })(content);
        }
        else if (content.length < 1) {
            throw new Error(`The passed template '${key}' does not contain any valid HTMLElement.`);
        }
        return content[0];
    }
}
/**
 * Instance Storage
 */
Templates.instance = null;
/**
 * JaX Plugin initializer
 * @param JaX
 */
function TemplatesPlugin(JaX) {
    JaX.set('templates', new Templates(JaX));
    JaX.directive('template', new Directive('template', (target) => {
        JaX.get('templates').set(target.dataset.template, target);
    }, { lazy: false }));
}/**
 * Loop through each element of an element stack.
 * @param eos Element(s) or Selector string.
 * @param handler Callback handler for each single element.
 * @returns
 */
function each(eos, handler) {
    if (typeof eos === 'string') {
        eos = this.query(eos);
    }
    if (eos !== null && typeof eos[Symbol.iterator] === 'function') {
        [].forEach.call(eos, handler);
    }
}
/**
 * Filter an element stack.
 * @param eos Element(s) or Selector string.
 * @param handler Callback handler for each single element.
 * @returns
 */
function filter(eos, handler) {
    if (typeof eos === 'string') {
        eos = this.query(eos);
    }
    if (eos !== null && typeof eos[Symbol.iterator] === 'function') {
        return [].filter.call(eos, handler);
    }
    else {
        return [];
    }
}/**
 * Event Binding
 * @param eos
 * @param events
 * @param handler
 * @returns
 */
function on(eos, events, handler) {
    if (typeof eos === 'string') {
        eos = this.query(eos);
    }
    if (typeof events === 'string') {
        events = events.split(',').map(e => e.trim());
    }
    [].forEach.call(eos, target => {
        events.forEach(event => {
            target.addEventListener(event, handler);
        });
    });
}
/**
 * Live Event Binding
 * @param context
 * @param selector
 * @param events
 * @param handler
 * @returns
 */
function live(context, selector, events, handler) {
    if (typeof events === 'string') {
        events = events.split(',').map(e => e.trim());
    }
    events.forEach(event => {
        context.addEventListener(event, (event) => {
            let target = event.target;
            let found = target.closest(selector);
            if (found) {
                handler.call(target, event);
            }
        });
    });
}
/**
 * Trigger an Event
 * @param target
 * @param event
 * @param eventDict
 * @returns
 */
function trigger(target, event, eventDict) {
    const ev = new CustomEvent(event, eventDict);
    target.dispatchEvent(ev);
}async function handleMenu(JaX) {
    const closeIcon = await JaX.get('icons').load('x-lg');
    await ready();
    // Get Menu Elements
    const menuButton = JaX.select('[data-crate="menu"]');
    const menuIcon = menuButton.children[0];
    const menu = JaX.select('#crateMenu');
    // Menu actions
    const openMenu = () => {
        menuButton.classList.add('disabled');
        menuButton.dataset.menuVisible = '1';
        menu.classList.add('in-transition', 'show');
        setTimeout(() => {
            menu.classList.remove('in-transition');
            menuButton.classList.remove('disabled', 'btn-light');
            menuButton.classList.add('btn-dark');
            menuButton.innerHTML = '';
            menuButton.appendChild(closeIcon);
        }, 300);
    };
    const closeMenu = () => {
        menuButton.classList.add('disabled');
        delete menuButton.dataset.menuVisible;
        menu.classList.add('in-transition');
        menu.classList.remove('show');
        setTimeout(() => {
            menu.classList.remove('in-transition');
            menuButton.classList.remove('disabled', 'btn-dark');
            menuButton.classList.add('btn-light');
            menuButton.innerHTML = '';
            menuButton.appendChild(menuIcon);
        }, 300);
    };
    // Toggle Menu
    menuButton.addEventListener('click', (event) => {
        if ('menuVisible' in menuButton.dataset) {
            closeMenu();
        }
        else {
            openMenu();
        }
    });
    // Close Menu on Switch
    document.querySelector('#pinCrateMenu').addEventListener('click', () => {
        if ('menuVisible' in menuButton.dataset) {
            closeMenu();
        }
    });
}async function handleColorScheme(JaX) {
    JaX.live(document.body, '[data-crate="color-scheme"]', 'click', (event) => {
        event.preventDefault();
        const target = event.target.closest('[data-crate]');
        const value = target.dataset.value;
        const current = localStorage.getItem('color-scheme') || 'light';
        const indicator = JaX.select('[data-popover="crate_color_scheme"] > div');
        const popover = JaX.select('#popover__crate_color_scheme');
        // Set new Value
        localStorage.setItem('color-scheme', value);
        // Append transition styles
        let styles = document.createElement('style');
        styles.innerHTML = '*, *::before, *::after { transition: all 300ms ease-in-out; }';
        document.head.appendChild(styles);
        // Remove Previous Color Scheme
        if (current === 'light' || current === 'dark') {
            document.documentElement.classList.remove(current);
        }
        else if (current === 'focus') {
            document.documentElement.classList.remove('dark');
            document.documentElement.classList.remove('focus');
        }
        indicator.classList.remove(`scheme-${current}`);
        // Add New Color Scheme
        if (value === 'light' || value === 'dark') {
            document.documentElement.classList.add(value);
        }
        else if (value === 'focus') {
            document.documentElement.classList.add('dark');
            document.documentElement.classList.add('focus');
        }
        indicator.classList.add(`scheme-${value}`);
        // Select on Popover
        if (popover) {
            popover.querySelector('.current').classList.remove('current');
            popover.querySelector(`[data-value="${value}"]`).classList.add('current');
        }
        // Remove transition styles
        setTimeout(() => styles.remove(), 320);
    });
}async function handleDashboard(JaX) {
    const datetimes = JaX.query('[data-crate="date"],[data-crate="time"],[data-crate="datetime"]');
    JaX.each(datetimes, (element) => {
        const format = element.dataset.format || null;
        if (!format) {
            return;
        }
        setInterval(((element, format) => {
            element.innerText = dayjs().format(format);
        }).bind(null, element, format), 1000);
        element.innerText = dayjs().format(format);
    });
}const JaX = new JaXCore;
window['JaX'] = JaX;
JaX.utility('each', each);
JaX.utility('filter', filter);
JaX.utility('on', on);
JaX.utility('live', live);
JaX.utility('trigger', trigger);
JaX.plugin(IconsPlugin);
JaX.plugin(OffcanvasPlugin);
JaX.plugin(PopoverPlugin);
JaX.plugin(TemplatesPlugin);
handleMenu(JaX);
handleColorScheme(JaX);
handleDashboard(JaX);
JaX.start();export{JaX as default};